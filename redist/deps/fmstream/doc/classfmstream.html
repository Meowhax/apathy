<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Memory-mapped files stream: fmstream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Memory-mapped files stream
   </div>
   <div id="projectbrief">Provide read-write access to memory-mapped files on Windows and POSIX systems.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfmstream.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfmstream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fmstream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>fmstream provides an interface to read/write data from/to memory-mapped files as input/output streams.  
 <a href="classfmstream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fmstream_8h_source.html">fmstream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fmstream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfmstream.png" usemap="#fmstream_map" alt=""/>
  <map id="fmstream_map" name="fmstream_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae709bb68fa81da33e19383b38a27e0d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#ae709bb68fa81da33e19383b38a27e0d8">fmstream</a> ()</td></tr>
<tr class="memdesc:ae709bb68fa81da33e19383b38a27e0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct object.  <a href="#ae709bb68fa81da33e19383b38a27e0d8"></a><br/></td></tr>
<tr class="separator:ae709bb68fa81da33e19383b38a27e0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b43ce4b73dfd35637b72d495d21f3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#a43b43ce4b73dfd35637b72d495d21f3b">fmstream</a> (const char *path_name, std::streamsize max_length=0, std::streamoff offset=0)</td></tr>
<tr class="memdesc:a43b43ce4b73dfd35637b72d495d21f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct object and open or create a file.  <a href="#a43b43ce4b73dfd35637b72d495d21f3b"></a><br/></td></tr>
<tr class="separator:a43b43ce4b73dfd35637b72d495d21f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9973d47a33f99981df21893ec277b60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9973d47a33f99981df21893ec277b60"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#ab9973d47a33f99981df21893ec277b60">~fmstream</a> ()</td></tr>
<tr class="memdesc:ab9973d47a33f99981df21893ec277b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the fmstream object. <br/></td></tr>
<tr class="separator:ab9973d47a33f99981df21893ec277b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9fcfe7d422b5468a9aa5a80ce3d4cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfilemappingbuf.html">filemappingbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#aff9fcfe7d422b5468a9aa5a80ce3d4cd">rdbuf</a> () const </td></tr>
<tr class="memdesc:aff9fcfe7d422b5468a9aa5a80ce3d4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the associated filemappingbuf object.  <a href="#aff9fcfe7d422b5468a9aa5a80ce3d4cd"></a><br/></td></tr>
<tr class="separator:aff9fcfe7d422b5468a9aa5a80ce3d4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afece5ec720c02c57dc61baf642ac3427"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#afece5ec720c02c57dc61baf642ac3427">is_open</a> () const </td></tr>
<tr class="memdesc:afece5ec720c02c57dc61baf642ac3427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a file is open.  <a href="#afece5ec720c02c57dc61baf642ac3427"></a><br/></td></tr>
<tr class="separator:afece5ec720c02c57dc61baf642ac3427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eba4a3139d89eee35b675dd31b5845b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#a4eba4a3139d89eee35b675dd31b5845b">open</a> (const char *path_name, std::streamsize max_length=0, std::streamoff offset=0)</td></tr>
<tr class="memdesc:a4eba4a3139d89eee35b675dd31b5845b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open file.  <a href="#a4eba4a3139d89eee35b675dd31b5845b"></a><br/></td></tr>
<tr class="separator:a4eba4a3139d89eee35b675dd31b5845b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5da922f1644ba6144f8a5bf5dc3cfd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#ab5da922f1644ba6144f8a5bf5dc3cfd1">close</a> ()</td></tr>
<tr class="memdesc:ab5da922f1644ba6144f8a5bf5dc3cfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close file.  <a href="#ab5da922f1644ba6144f8a5bf5dc3cfd1"></a><br/></td></tr>
<tr class="separator:ab5da922f1644ba6144f8a5bf5dc3cfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac357ba636901feca584f74e481c3601f"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#ac357ba636901feca584f74e481c3601f">ptellg</a> ()</td></tr>
<tr class="memdesc:ac357ba636901feca584f74e481c3601f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of the get pointer.  <a href="#ac357ba636901feca584f74e481c3601f"></a><br/></td></tr>
<tr class="separator:ac357ba636901feca584f74e481c3601f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d701bbd6fc8a30ad8e240637e0f4a4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#af7d701bbd6fc8a30ad8e240637e0f4a4">ptellp</a> ()</td></tr>
<tr class="memdesc:af7d701bbd6fc8a30ad8e240637e0f4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of the put pointer.  <a href="#af7d701bbd6fc8a30ad8e240637e0f4a4"></a><br/></td></tr>
<tr class="separator:af7d701bbd6fc8a30ad8e240637e0f4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80079b046ca5dc1495ab066bcd7e6188"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#a80079b046ca5dc1495ab066bcd7e6188">pseekg</a> (const void *ptr)</td></tr>
<tr class="memdesc:a80079b046ca5dc1495ab066bcd7e6188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the get pointer.  <a href="#a80079b046ca5dc1495ab066bcd7e6188"></a><br/></td></tr>
<tr class="separator:a80079b046ca5dc1495ab066bcd7e6188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd9ee89551fa8ff208828d5448c6267"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#a0cd9ee89551fa8ff208828d5448c6267">pseekp</a> (void *ptr)</td></tr>
<tr class="memdesc:a0cd9ee89551fa8ff208828d5448c6267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position of the put pointer.  <a href="#a0cd9ee89551fa8ff208828d5448c6267"></a><br/></td></tr>
<tr class="separator:a0cd9ee89551fa8ff208828d5448c6267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62a2744c0195e23d675f34eba422fec"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#ac62a2744c0195e23d675f34eba422fec">data</a> () const </td></tr>
<tr class="memdesc:ac62a2744c0195e23d675f34eba422fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the read-only base address of the mapping.  <a href="#ac62a2744c0195e23d675f34eba422fec"></a><br/></td></tr>
<tr class="separator:ac62a2744c0195e23d675f34eba422fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ac95294fa40d695c7e74c5371e5241"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#ae7ac95294fa40d695c7e74c5371e5241">data</a> ()</td></tr>
<tr class="memdesc:ae7ac95294fa40d695c7e74c5371e5241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base address of the mapping.  <a href="#ae7ac95294fa40d695c7e74c5371e5241"></a><br/></td></tr>
<tr class="separator:ae7ac95294fa40d695c7e74c5371e5241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b26e0d7d8ec0bd13ce31f3826ec6a6"><td class="memItemLeft" align="right" valign="top">std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#ac6b26e0d7d8ec0bd13ce31f3826ec6a6">size</a> () const </td></tr>
<tr class="memdesc:ac6b26e0d7d8ec0bd13ce31f3826ec6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum byte length of the mapping.  <a href="#ac6b26e0d7d8ec0bd13ce31f3826ec6a6"></a><br/></td></tr>
<tr class="separator:ac6b26e0d7d8ec0bd13ce31f3826ec6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C++11</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following methods requires some features introduced by the latest revision of the C++ standard (2011).</p>
<p>Older compilers may not support it. </p>
</div></td></tr>
<tr class="memitem:afb03f0ac90a0124597332eb5bb9aa541"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#afb03f0ac90a0124597332eb5bb9aa541">fmstream</a> (<a class="el" href="classfmstream.html">fmstream</a> &amp;&amp;rhs_stream)</td></tr>
<tr class="memdesc:afb03f0ac90a0124597332eb5bb9aa541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor (requires C++11).  <a href="#afb03f0ac90a0124597332eb5bb9aa541"></a><br/></td></tr>
<tr class="separator:afb03f0ac90a0124597332eb5bb9aa541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2134b882db0b8f64c463c80bbc5e40ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfmstream.html">fmstream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#a2134b882db0b8f64c463c80bbc5e40ba">operator=</a> (<a class="el" href="classfmstream.html">fmstream</a> &amp;&amp;rhs_stream)</td></tr>
<tr class="memdesc:a2134b882db0b8f64c463c80bbc5e40ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment (requires C++11).  <a href="#a2134b882db0b8f64c463c80bbc5e40ba"></a><br/></td></tr>
<tr class="separator:a2134b882db0b8f64c463c80bbc5e40ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9860a4e40a9c367388d3dea03da8f39d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfmstream.html#a9860a4e40a9c367388d3dea03da8f39d">swap</a> (<a class="el" href="classfmstream.html">fmstream</a> &amp;stream)</td></tr>
<tr class="memdesc:a9860a4e40a9c367388d3dea03da8f39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap internals (requires C++11).  <a href="#a9860a4e40a9c367388d3dea03da8f39d"></a><br/></td></tr>
<tr class="separator:a9860a4e40a9c367388d3dea03da8f39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>fmstream provides an interface to read/write data from/to memory-mapped files as input/output streams. </p>
<p>The objects of this class maintain internally a pointer to a filemappingbuf object that can be obtained by calling member rdbuf. The file to be associated with the stream can be specified either as a parameter in the constructor or by calling member open. After all necessary operations on a file have been performed, it can be closed (or disassociated) by calling member close. Once closed, the same file stream object may be used to open another file. The member function is_open can be used to determine whether the stream object is currently associated with a file. fmstream can be used in place of std::fstream. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae709bb68fa81da33e19383b38a27e0d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmstream::fmstream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct object. </p>
<p>Constructs an object of the fstream class. This implies the initialization of the associated filemappingbuf object and the call to the constructor of its base class with the filemappingbuf object as parameter. </p>

</div>
</div>
<a class="anchor" id="a43b43ce4b73dfd35637b72d495d21f3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fmstream::fmstream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamsize&#160;</td>
          <td class="paramname"><em>max_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamoff&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct object and open or create a file. </p>
<p>Constructs an object of the fstream class. This implies the initialization of the associated filemappingbuf object and the call to the constructor of its base class with the filemappingbuf object as parameter. The stream is associated with a physical file as if a call to the member function open with the same parameters was made. If the constructor is not successful in opening the file, the object is still created although no file is associated to the stream buffer and the stream's failbit is set (which can be checked with inherited member fail). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_name</td><td>C-string contains the name of the file to be opened or created. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum length of the file mapping. If this parameter are 0, the maximum length of the file mapping object is equal to the current size of the file. </td></tr>
    <tr><td class="paramname">offset</td><td>File offset where the mapping begins. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the offset granularity of the system, use <a class="el" href="classfilemapping.html#a69b1b97a0289e998fe7251b6def8fd64" title="Get memory offset granularity.">filemapping::offset_granularity()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a4eba4a3139d89eee35b675dd31b5845b" title="Open file.">open()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#afece5ec720c02c57dc61baf642ac3427" title="Check if a file is open.">is_open()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#ab5da922f1644ba6144f8a5bf5dc3cfd1" title="Close file.">close()</a> </dd>
<dd>
<a class="el" href="classfilemapping.html#a69b1b97a0289e998fe7251b6def8fd64" title="Get memory offset granularity.">filemapping::offset_granularity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb03f0ac90a0124597332eb5bb9aa541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fmstream::fmstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfmstream.html">fmstream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor (requires C++11). </p>
<p>Acquires the contents of rhs_stream, by move-assigning its members and base classes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs_stream</td><td>File stream to move. rhs_stream becomes of invalid state after the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a9860a4e40a9c367388d3dea03da8f39d" title="Swap internals (requires C++11).">swap()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#a2134b882db0b8f64c463c80bbc5e40ba" title="Move assignment (requires C++11).">operator=()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab5da922f1644ba6144f8a5bf5dc3cfd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fmstream::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close file. </p>
<p>Closes the file currently associated with the object and disassociates it. The function fails if no file is currently open (associated) with this object. On failure, the failbit flag is set (which can be checked with member fail), and depending on the value set with exceptions an exception may be thrown. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a4eba4a3139d89eee35b675dd31b5845b" title="Open file.">open()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#afece5ec720c02c57dc61baf642ac3427" title="Check if a file is open.">is_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac62a2744c0195e23d675f34eba422fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * fmstream::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the read-only base address of the mapping. </p>
<p>The function fails if no file is currently open (associated) with this object. </p>
<dl class="section return"><dt>Returns</dt><dd>In case of success, returns the constant base address of the mapping. In case of failure, a null pointer is returned. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#ac6b26e0d7d8ec0bd13ce31f3826ec6a6" title="Get the maximum byte length of the mapping.">size()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae7ac95294fa40d695c7e74c5371e5241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * fmstream::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the base address of the mapping. </p>
<p>The function fails if no file is currently open (associated) with this object. </p>
<dl class="section return"><dt>Returns</dt><dd>In case of success, returns the base address of the mapping. In case of failure, a null pointer is returned. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#ac6b26e0d7d8ec0bd13ce31f3826ec6a6" title="Get the maximum byte length of the mapping.">size()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afece5ec720c02c57dc61baf642ac3427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fmstream::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a file is open. </p>
<p>Returns true if the stream is currently associated with a file, and false otherwise. The stream is associated with a file if either a previous call to member open succeeded or if the object was successfully constructed using the parameterized constructor, and close has not been called since. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a file is open, i.e. associated to this stream object. false otherwise. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a4eba4a3139d89eee35b675dd31b5845b" title="Open file.">open()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#ab5da922f1644ba6144f8a5bf5dc3cfd1" title="Close file.">close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4eba4a3139d89eee35b675dd31b5845b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fmstream::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamsize&#160;</td>
          <td class="paramname"><em>max_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamoff&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open file. </p>
<p>Opens a file whose name is path_name, associating its content with the stream object to perform input/output operations on it. The operations allowed and some operating details depend on parameter mode. If the object already has a file associated (open), this function fails. If the file do not exist, the file is created with the 'offset + max_length' size. If the size of the opened file is less than 'offset + max_length', the file growing. If the size of the opened file is greater than 'offset + max_length', the file is not truncated. An attempt to map a file with a length of 0 fails. On failure, the failbit flag is set (which can be checked with member fail), and depending on the value set with exceptions an exception may be thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_name</td><td>C-string contains the name of the file to be opened. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum length of the file mapping. If this parameter are 0, the maximum length of the file mapping object is equal to the current size of the file. </td></tr>
    <tr><td class="paramname">offset</td><td>File offset where the mapping begins. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the offset granularity of the system, use <a class="el" href="classfilemapping.html#a69b1b97a0289e998fe7251b6def8fd64" title="Get memory offset granularity.">filemapping::offset_granularity()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#afece5ec720c02c57dc61baf642ac3427" title="Check if a file is open.">is_open()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#ab5da922f1644ba6144f8a5bf5dc3cfd1" title="Close file.">close()</a> </dd>
<dd>
<a class="el" href="classfilemapping.html#a69b1b97a0289e998fe7251b6def8fd64" title="Get memory offset granularity.">filemapping::offset_granularity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2134b882db0b8f64c463c80bbc5e40ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfmstream.html">fmstream</a> &amp; fmstream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfmstream.html">fmstream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment (requires C++11). </p>
<p>Closes the source stream (as if member close was called), and then acquires the contents of rhs_stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs_stream</td><td>File stream to move. rhs_stream becomes of invalid state after the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a9860a4e40a9c367388d3dea03da8f39d" title="Swap internals (requires C++11).">swap()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a80079b046ca5dc1495ab066bcd7e6188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; fmstream::pseekg </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position of the get pointer. </p>
<p>The get pointer determines the next location to be read in the source associated to the stream. The function fails if no file is currently open (associated) with this object. On failure, the failbit flag is set (which can be checked with member fail), and depending on the value set with exceptions an exception may be thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>New absolute position for the input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns *this. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a0cd9ee89551fa8ff208828d5448c6267" title="Sets the position of the put pointer.">pseekp()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#ac357ba636901feca584f74e481c3601f" title="Get position of the get pointer.">ptellg()</a> </dd>
<dd>
std::istream::seekg() </dd></dl>

</div>
</div>
<a class="anchor" id="a0cd9ee89551fa8ff208828d5448c6267"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; fmstream::pseekp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position of the put pointer. </p>
<p>The put pointer determines the location in the output sequence where the next output operation is going to take place. The function fails if no file is currently open (associated) with this object. On failure, the failbit flag is set (which can be checked with member fail), and depending on the value set with exceptions an exception may be thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>New absolute position for the output pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns *this. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a80079b046ca5dc1495ab066bcd7e6188" title="Sets the position of the get pointer.">pseekg()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#af7d701bbd6fc8a30ad8e240637e0f4a4" title="Get position of the put pointer.">ptellp()</a> </dd>
<dd>
std::istream::seekp() </dd></dl>

</div>
</div>
<a class="anchor" id="ac357ba636901feca584f74e481c3601f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * fmstream::ptellg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get position of the get pointer. </p>
<p>The get pointer determines the next location in the input sequence to be read by the next input operation. The function fails if no file is currently open (associated) with this object. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the address of the get pointer. In case of failure, a null pointer is returned. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#af7d701bbd6fc8a30ad8e240637e0f4a4" title="Get position of the put pointer.">ptellp()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#a80079b046ca5dc1495ab066bcd7e6188" title="Sets the position of the get pointer.">pseekg()</a> </dd>
<dd>
std::istream::tellg() </dd></dl>

</div>
</div>
<a class="anchor" id="af7d701bbd6fc8a30ad8e240637e0f4a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * fmstream::ptellp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get position of the put pointer. </p>
<p>The put pointer determines the location in the output sequence where the next output operation is going to take place. The function fails if no file is currently open (associated) with this object. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the address of the put pointer. In case of failure, a null pointer is returned. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#ac357ba636901feca584f74e481c3601f" title="Get position of the get pointer.">ptellg()</a> </dd>
<dd>
<a class="el" href="classfmstream.html#a0cd9ee89551fa8ff208828d5448c6267" title="Sets the position of the put pointer.">pseekp()</a> </dd>
<dd>
std::istream::tellp() </dd></dl>

</div>
</div>
<a class="anchor" id="aff9fcfe7d422b5468a9aa5a80ce3d4cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfilemappingbuf.html">filemappingbuf</a> * fmstream::rdbuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the associated filemappingbuf object. </p>
<p>Returns a pointer to the filemappingbuf object associated with the stream. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the filemappingbuf object associated with the stream. Notice that for any successfully constructed fmstream object this pointer is never a null pointer, even if no files have been opened or if the stream is unbuffered. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6b26e0d7d8ec0bd13ce31f3826ec6a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::streamsize fmstream::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum byte length of the mapping. </p>
<p>The function fails if no file is currently open (associated) with this object. </p>
<dl class="section return"><dt>Returns</dt><dd>In case of success, returns the length of the mapping. In case of failure, 0 is returned. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#ae7ac95294fa40d695c7e74c5371e5241" title="Get the base address of the mapping.">data()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9860a4e40a9c367388d3dea03da8f39d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fmstream::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfmstream.html">fmstream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap internals (requires C++11). </p>
<p>Exchanges the state of the stream with those of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>fmstream to exchange the state with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classfmstream.html#a2134b882db0b8f64c463c80bbc5e40ba" title="Move assignment (requires C++11).">operator=()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fmstream_8h_source.html">fmstream.h</a></li>
<li>fmstream.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classfmstream.html">fmstream</a></li>
    <li class="footer">Generated on Tue Sep 24 2013 16:06:42 for Memory-mapped files stream by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
